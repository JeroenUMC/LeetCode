#!/usr/bin/env python3
"""
Automated Test Runner with Logging

This script runs pytest tests and logs results with timestamps.
Used to track test results after code changes.

Supports:
- Running all tests (default)
- Running only tests for specific changed files (smart mode)
"""

import argparse
import json
import os
import re
import subprocess
import sys
from datetime import datetime, timedelta
from pathlib import Path


def get_log_timestamp():
    now = datetime.now().astimezone()
    offset_hours = os.getenv("TEST_LOG_TZ_OFFSET_HOURS")
    if offset_hours:
        try:
            now += timedelta(hours=float(offset_hours))
        except ValueError:
            pass
    return now.strftime("%Y-%m-%d %H:%M:%S")


def notebook_to_test_file(notebook_path):
    """
    Map a notebook file to its corresponding test file.
    
    Args:
        notebook_path: Path to notebook (e.g., "42. Trapping Rain Water.ipynb")
        
    Returns:
        str: Test file path (e.g., "tests/test_42_trapping_rain_water.py")
        None if no mapping found
    """
    notebook_name = Path(notebook_path).stem  # Remove .ipynb extension
    
    # Match pattern: "{number}. {problem name}"
    match = re.match(r'^(\d+)\.\s+(.+)$', notebook_name)
    if not match:
        return None
    
    number = match.group(1)
    problem_name = match.group(2)
    
    # Convert to snake_case
    snake_case_name = re.sub(r'[^\w\s]', '', problem_name)  # Remove special chars
    snake_case_name = re.sub(r'\s+', '_', snake_case_name)  # Replace spaces with _
    snake_case_name = snake_case_name.lower()
    
    test_file = f"tests/test_{number}_{snake_case_name}.py"
    
    # Check if test file exists
    if Path(test_file).exists():
        return test_file
    return None


def find_relevant_tests(changed_files):
    """
    Find test files relevant to the changed files.
    
    Args:
        changed_files: List of file paths that changed
        
    Returns:
        list: List of test file paths to run
    """
    test_files = set()
    
    for file_path in changed_files:
        # If it's already a test file, include it
        if file_path.startswith("tests/test_") and file_path.endswith(".py"):
            test_files.add(file_path)
        # If it's a notebook, find corresponding test
        elif file_path.endswith(".ipynb"):
            test_file = notebook_to_test_file(file_path)
            if test_file:
                test_files.add(test_file)
    
    return sorted(test_files)


def create_failure_notification(exit_code, changed_files, test_targets, stdout):
    """
    Create a visible notification file when tests fail.
    
    Args:
        exit_code: The pytest exit code
        changed_files: List of changed files
        test_targets: List of test files that were run
        stdout: The pytest output
    """
    if exit_code == 0:
        # Tests passed, remove any existing failure file
        failure_file = Path("TEST_FAILURES.md")
        if failure_file.exists():
            failure_file.unlink()
        return
    
    # Tests failed - create notification file
    timestamp = get_log_timestamp()
    
    # Parse failures from output
    failures_section = ""
    if "FAILURES" in stdout:
        failures_section = stdout.split("FAILURES")[1].split("short test summary")[0]
    
    # Count failures
    failed_count = stdout.count("FAILED")
    passed_count = stdout.count("PASSED")
    
    notification_content = f"""# ‚ö†Ô∏è TEST FAILURES DETECTED ‚ö†Ô∏è

**Timestamp:** {timestamp}

## Summary
- ‚ùå **{failed_count} test(s) FAILED**
- ‚úÖ {passed_count} test(s) passed

## Changed Files
{chr(10).join(f"- `{f}`" for f in changed_files) if changed_files else "- (all tests run)"}

## Failed Test Files
{chr(10).join(f"- `{t}`" for t in test_targets)}

## Quick Actions
1. Check the detailed output in `test_log.txt`
2. Review your recent changes in the files above
3. Run tests manually: `python run_tests_auto.py --files "{changed_files[0] if changed_files else ''}"` 
4. Once fixed, this file will auto-delete when tests pass

---

## Failure Details

```
{failures_section.strip() if failures_section else "See test_log.txt for full details"}
```

## Full Output
See `test_log.txt` for complete test output.

---
*This file was auto-generated by the test automation system.*
*It will be automatically deleted when all tests pass.*
"""
    
    # Write notification file
    with open("TEST_FAILURES.md", "w", encoding="utf-8") as f:
        f.write(notification_content)
    
    print("\n" + "üî¥" * 40)
    print("‚ö†Ô∏è  TEST FAILURES DETECTED!")
    print(f"‚ö†Ô∏è  {failed_count} test(s) failed")
    print("‚ö†Ô∏è  Check TEST_FAILURES.md for details")
    print("üî¥" * 40 + "\n")


def run_tests_with_logging(log_file="test_log.txt", verbose=True, changed_files=None):
    """
    Run pytest tests and log results.
    
    Args:
        log_file: Path to log file
        verbose: Whether to print output to console
        changed_files: List of changed files (for smart test selection)
                      If None, run all tests
        
    Returns:
        int: Exit code from pytest (0 = all pass, non-zero = failures)
    """
    log_path = Path(log_file)
    timestamp = get_log_timestamp()
    
    # Determine which tests to run
    if changed_files:
        test_targets = find_relevant_tests(changed_files)
        if not test_targets:
            # No relevant tests found, run all tests as fallback
            test_targets = ["tests/"]
            test_mode = "all (no specific tests found for changed files)"
        else:
            test_mode = f"smart ({len(test_targets)} test file(s))"
    else:
        test_targets = ["tests/"]
        test_mode = "all"
    
    # Run pytest
    cmd = [sys.executable, "-m", "pytest"] + test_targets + ["-v"]
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    # Prepare log entry
    separator = "=" * 80
    log_entry = f"\n{separator}\n"
    log_entry += f"Test Run: {timestamp}\n"
    log_entry += f"Mode: {test_mode}\n"
    if changed_files and test_targets != ["tests/"]:
        log_entry += f"Changed Files: {', '.join(changed_files)}\n"
        log_entry += f"Test Files: {', '.join(test_targets)}\n"
    log_entry += f"Exit Code: {result.returncode}\n"
    log_entry += f"{separator}\n"
    log_entry += "STDOUT:\n"
    log_entry += result.stdout
    log_entry += "\nSTDERR:\n"
    log_entry += result.stderr
    log_entry += f"\n{separator}\n"
    
    # Append to log file
    with open(log_path, "a", encoding="utf-8") as f:
        f.write(log_entry)
    
    # Create failure notification if tests failed
    create_failure_notification(
        exit_code=result.returncode,
        changed_files=changed_files or [],
        test_targets=test_targets,
        stdout=result.stdout
    )
    
    # Print summary
    if verbose:
        print(f"\n{'='*80}")
        print(f"Test run completed at {timestamp}")
        print(f"Mode: {test_mode}")
        if changed_files and test_targets != ["tests/"]:
            print(f"Changed files: {', '.join(changed_files)}")
            print(f"Test files: {', '.join(test_targets)}")
        print(f"Exit code: {result.returncode}")
        print(f"Results logged to: {log_path.absolute()}")
        print(f"{'='*80}\n")
        print(result.stdout)
        if result.stderr:
            print("STDERR:")
            print(result.stderr)
    
    return result.returncode


def main():
    parser = argparse.ArgumentParser(
        description="Run tests with logging. Supports smart test selection."
    )
    parser.add_argument(
        "--files",
        nargs="+",
        help="Files that changed (for smart test selection). If omitted, runs all tests."
    )
    parser.add_argument(
        "--log-file",
        default="test_log.txt",
        help="Path to log file (default: test_log.txt)"
    )
    parser.add_argument(
        "--quiet",
        action="store_true",
        help="Suppress console output"
    )
    
    args = parser.parse_args()
    
    exit_code = run_tests_with_logging(
        log_file=args.log_file,
        verbose=not args.quiet,
        changed_files=args.files
    )
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
